// use crate::{inst_match};
use super::{OpCode::*, FlatRiscV};


macro_rules! flag_gen {
  ($name:ident, $value:expr) => {
  #[allow(non_upper_case_globals)]
  pub const $name: u16 = $value;
  };
}

//////////////////////////////
// operator number gen

// cmp flag
flag_gen!(eq  , 0b000);
flag_gen!(ne  , 0b001);
flag_gen!(lt  , 0b100);
flag_gen!(ge  , 0b101);
flag_gen!(ltu , 0b110);
flag_gen!(geu , 0b111);

// load store flag
flag_gen!(b , 0b000);
flag_gen!(h , 0b001);
flag_gen!(w , 0b010);
flag_gen!(bu, 0b100);
flag_gen!(hu, 0b101);

// operator
flag_gen!(add , 0b0000);
flag_gen!(sub , 0b0001);
flag_gen!(sll , 0b0010);
flag_gen!(slt , 0b0100);
flag_gen!(sltu, 0b0110);
flag_gen!(xor , 0b1000);
flag_gen!(srl , 0b1010);
flag_gen!(sra , 0b1011);
flag_gen!(or  , 0b1100);
flag_gen!(and , 0b1110);

// fence.i
flag_gen!(i, 0b1);

// ecall
flag_gen!(call, 0b0);
flag_gen!(ret, 0b1);  // break, break is rust keyword


// csr
flag_gen!(rw  , 0b001);
flag_gen!(rs  , 0b010);
flag_gen!(rc  , 0b011);
flag_gen!(rwi , 0b101);
flag_gen!(rsi , 0b110);
flag_gen!(rci , 0b111);


//////////////////////////////
/// impl

pub fn flat_disasm(src: &[u8]) -> Option<(FlatRiscV, usize)> {
  inst_match_packet!(src,
    b"????????????????????_?????_0110111", utype -> lui;
    b"????????????????????_?????_0010111", utype -> auipc;
    b"????????????????????_?????_1101111", jtype -> jal;
    b"?????????????????000_?????_1100111", itype -> jalr;
    b"?????????????????000_?????_1100011", btype -> br.eq;
    b"?????????????????001_?????_1100011", btype -> br.ne;
    b"?????????????????100_?????_1100011", btype -> br.lt;
    b"?????????????????101_?????_1100011", btype -> br.ge;
    b"?????????????????110_?????_1100011", btype -> br.ltu;
    b"?????????????????111_?????_1100011", btype -> br.geu;
    b"?????????????????000_?????_0000011", itype -> load.b;
    b"?????????????????001_?????_0000011", itype -> load.h;
    b"?????????????????010_?????_0000011", itype -> load.w;
    b"?????????????????100_?????_0000011", itype -> load.bu;
    b"?????????????????101_?????_0000011", itype -> load.hu;
    b"?????????????????000_?????_0100011", stype -> store.b;
    b"?????????????????001_?????_0100011", stype -> store.h;
    b"?????????????????010_?????_0100011", stype -> store.w;
    b"?????????????????000_?????_0010011", itype -> iop.add;
    b"0000000??????????001_?????_0010011", itype -> iop.sll;
    b"?????????????????010_?????_0010011", itype -> iop.slt;
    b"?????????????????011_?????_0010011", itype -> iop.sltu;
    b"?????????????????100_?????_0010011", itype -> iop.xor;
    b"0000000??????????101_?????_0010011", itype -> iop.srl;
    b"0100000??????????101_?????_0010011", itype -> iop.sra;
    b"?????????????????110_?????_0010011", itype -> iop.or;
    b"?????????????????111_?????_0010011", itype -> iop.and;
    b"0000000??????????000_?????_0110011", rtype -> op.add;
    b"0100000??????????000_?????_0110011", rtype -> op.sub;
    b"0000000??????????001_?????_0110011", rtype -> op.sll;
    b"0000000??????????010_?????_0110011", rtype -> op.slt;
    b"0000000??????????011_?????_0110011", rtype -> op.sltu;
    b"0000000??????????100_?????_0110011", rtype -> op.xor;
    b"0000000??????????101_?????_0110011", rtype -> op.srl;
    b"0100000??????????101_?????_0110011", rtype -> op.sra;
    b"0000000??????????110_?????_0110011", rtype -> op.or;
    b"0000000??????????111_?????_0110011", rtype -> op.and;
    b"0000????????00000000_00000_0001111", itype -> fence;
    b"00000000000000000001_00000_0001111", itype -> fence.i;
    b"00000000000000000000_00000_1110011", itype -> excep.call;
    b"00000000000100000000_00000_1110011", itype -> excep.ret;
    b"?????????????????001_?????_1110011", itype -> csr.rw;
    b"?????????????????010_?????_1110011", itype -> csr.rs;
    b"?????????????????011_?????_1110011", itype -> csr.rc;
    b"?????????????????101_?????_1110011", itype -> csr.rwi;
    b"?????????????????110_?????_1110011", itype -> csr.rsi;
    b"?????????????????111_?????_1110011", itype -> csr.rci;
  );
}


mod test {
  #[test]
  fn test1() {
    use super::flat_disasm;
    let src = 0b11111111111111111111_00000_0110111_u32.to_le_bytes();
    let _r = flat_disasm(&src).unwrap();
    // println!("out: {:?}", r);
  }
}